\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{float}
\usepackage[a4paper, margin = 2 cm]{geometry}
\usepackage{fancyhdr}
\usepackage{wrapfig}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algpseudocode}

\title{Parameterized Algorithms assignment 1}
\author{Dominik Wawszczak}
\date{2024-10-29}

\begin{document}
	\setlength{\parindent}{0 cm}
	
	Dominik Wawszczak \hfill Parameterized Algorithms
	
	student id number: 440014 \hfill assignment 1
	
	group number: 1
	
	\bigskip
	\hrule
	\bigskip
	
	\textbf{Task 1}
	
	\medskip
	
	Let
	\[ V(G) \ = \ \{v_{1}, \ldots, v_{n}\} \quad \text{and} \quad S_{n} \ = \
	\left\{ \sigma \ : \ \sigma \in \{1, \ldots, n\}^{\{1, \ldots, n\}} \ \wedge
	\ \sigma \ \text{is a bijection} \right\} \text{.} \]
	Define
	\[ \text{cutwidth}_{\sigma}(i) \ = \ |\{(u, v) \ : \ u \in \{v_{\sigma_{1}}
	\ldots v_{\sigma_{i}}\} \ \wedge \ v \in \{v_{\sigma_{i + 1}}, \ldots,
	v_{\sigma_{n}}\} \ \wedge \ (u, v) \in E(G)\}| \text{,} \]
	where \(\sigma \in S_{n}\) is any permutation. The objective is to find a
	permutation \(\sigma \in S_{n}\) that minimizes the value
	\[ \underset{i \in \{1, \ldots, n - 1\}}{\max} \
	\text{cutwidth}_{\sigma}(i) \]
	and to calculate this minimum.
	
	\medskip
	
	Define the function
	\[ \text{out}(X) \ = \ |\{(u, v) \ : \ u \in X \ \wedge \ v \in V(G)
	\setminus X \ \wedge \ (u, v) \in E(G)\}| \text{,} \]
	where \(X\) is any subset of \(V(G)\). Then
	\[ \text{cutwidth}_{\sigma}(i) \ = \ \text{out}(\{v_{\sigma_{1}}, \ldots,
	v_{\sigma_{i}}\}) \text{.} \]
	For any given \(X\), \(\text{out}(X)\) can be calculated in time
	\(n^{\mathcal{O}(1)}\).
	
	\medskip
	
	We will use dynamic programming over subsets. Define
	\[ \text{dp}(X) \ = \ \min \left\{ \underset{i \in
	\{1, \ldots, |X| - 1\}}{\max} \ \text{cutwidth}_{\sigma}(i) \ : \ \sigma \in
	S_{n} \ \wedge \ \{v_{\sigma_{1}}, \ldots, v_{\sigma_{|X|}}\} = X \right\}
	\text{,} \]
	where \(X\) is any subset of \(V(G)\). Then
	\begin{align*}
		\text{dp}(\emptyset) \ &= \ 0 \text{,} \\
		\text{dp}(X) \ &= \ \min \{\max(\text{dp}(X \setminus \{x\}),
		\text{out}(X \setminus \{x\})) \ : \ x \in X\} \text{.}
	\end{align*}
	The answer to the problem is \(\text{dp}(\{1, \ldots, n\})\). To compute
	\(\text{dp}\) for all subsets of \(V(G)\), we iterate over subsets in
	non-decreasing order of size. The time complexity of this algorithm is
	\(2^{n} \cdot n^{\mathcal{O}(1)}\).
	
	\newpage
	
	\textbf{Task 2}
	
	\medskip
	
	\underline{Lemma 1} A set of points \(S\), in which no three points are
	collinear, does not form the vertices of a convex polygon if and only if
	there exist points \(A, B, C, D \in S\) such that \(D\) lies inside
	\(\triangle ABC\).
	
	\medskip
	
	\underline{Proof of lemma 1} The implication ,,to the left'' is obvious,
	so we only need to prove the implication ,,to the right''. Let \(\{H_{1},
	\ldots, H_{h}\}\) be the convex hull of the set \(S\), with the assumption
	that these points are ordered counterclockwise along the hull. Let \(D\) be
	any point in \(S\) that does not belong to the hull, and let \(A = H_{1}\).
	There exists exactly one \(i \in \{2, \ldots, h - 1\}\) such that points
	\(H_{2}, \ldots, H_{i}\) lie on one side of the line \(AD\), while points
	\(H_{i + 1}, \ldots, H_{h}\) lie on the other side. Taking \(B = H_{i}\) and
	\(C = H_{i + 1}\), we will obtain the desired points.
	
	\medskip
	
	According to lemma 1, if there exist points \(A, B, C, D \in S\) such that
	\(D\) lies inside \(\triangle ABC\), then at least of these points must be
	removed from \(S\). This observation leads to the following algorithm:
	
	\begin{algorithm}
		\caption{ConvexDeletion} \label{alg:alg1}
		\begin{algorithmic}[1]
			\Procedure{ConvexDeletion}{$S, k$}
			    \If{no four points $A, B, C, D \in S$ satisfy that $D$ lies
			        inside $\triangle ABC$}
			        \State \Return true
			    \EndIf
			    \If{$k \leqslant 0$}
			        \State \Return false
			    \EndIf
			    \State Choose points $(A, B, C, D) \in S$ such that $D$ lies
			           inside $\triangle ABC$
			    \State \Return \Call{ConvexDeletion}{$S \setminus \{A\}, k - 1$}
			           \textbf{or}
			           \Call{ConvexDeletion}{$S \setminus \{B\}, k - 1$}
			           \textbf{or}
			    \Statex \hspace{4.685em}
			           \Call{ConvexDeletion}{$S \setminus \{C\}, k - 1$}
			           \textbf{or}
			           \Call{ConvexDeletion}{$S \setminus \{D\}, k - 1$}
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	Finding such quadruples of points \(A, B, C, D\) can easily be done in
	\(\mathcal{O} \big( n^{4} \big)\) time by examining all quadruples of
	points, calculating the relevant cross products for each, and comparing
	their signs. This can also be done in \(\mathcal{O} (n \log n)\) time by
	computing the convex hull using Graham's algorithm and applying the
	constructive proof of lemma 1.
	
	\medskip
	
	The depth of the recursion tree fro of the algorithm \ref{alg:alg1} is at
	most \(k\), since with each recursive call, the parameter \(k\) decreases
	by \(1\). Each node of this tree has at most four children, which gives us
	an upper bound on the number of nodes in the tree:
	\[ \sum\limits_{i = 0}^{k} 4^{i} \ = \ \frac{4^{k + 1} - 1}{3} \ = \
	\mathcal{O} \big( 4^{k} \big) \text{.} \]
	Therefore, the overall complexity of the algorithm \ref{alg:alg1} is
	\(\mathcal{O} \big( 4^{k} \big) \cdot n^{\mathcal{O}(1)}\).
\end{document}
