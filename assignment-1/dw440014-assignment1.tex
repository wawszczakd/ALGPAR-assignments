\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{float}
\usepackage[a4paper, margin = 2 cm]{geometry}
\usepackage{fancyhdr}
\usepackage{wrapfig}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algpseudocode}

\title{Algorytmy parametryzowane praca domowa 1}
\author{Dominik Wawszczak}
\date{2024-10-29}

\begin{document}
	\setlength{\parindent}{0 cm}
	
	Dominik Wawszczak \hfill Algorytmy Parametryzowane
	
	numer indeksu: 440014 \hfill praca domowa 1
	
	numer grupy: 1
	
	\bigskip
	\hrule
	\bigskip
	
	\textbf{Zadanie 1}
	
	\medskip
	
	Oznaczmy
	\[ V(G) \ = \ \{v_{1}, \ldots, v_{n}\} \quad \text{oraz} \quad S_{n} \ = \
	\left\{ \sigma \ : \ \sigma \in \{1, \ldots, n\}^{\{1, \ldots, n\}} \ \wedge
	\ \sigma \ \text{jest bijekcją} \right\} \text{.} \]
	Niech
	\[ \text{cutwidth}_{\sigma}(i) \ = \ |\{(u, v) \ : \ u \in \{v_{\sigma_{1}}
	\ldots v_{\sigma_{i}}\} \ \wedge \ v \in \{v_{\sigma_{i + 1}}, \ldots,
	v_{\sigma_{n}}\} \ \wedge \ (u, v) \in E(G)\}| \text{,} \]
	gdzie \(\sigma \in S_{n}\) jest dowolną permutacją. Celem jest znalezienie
	permutacji \(\sigma \in S_{n}\), dla której wartość
	\[ \underset{i \in \{1, \ldots, n - 1\}}{\max} \
	\text{cutwidth}_{\sigma}(i) \]
	jest najmniejsza możliwa. Konkretnie, chcemy obliczyć tę wartość.
	
	\medskip
	
	Zdefiniujmy funkcję
	\[ \text{out}(X) \ = \ |\{(u, v) \ : \ u \in X \ \wedge \ v \in V(G)
	\setminus X \ \wedge \ (u, v) \in E(G)\}| \text{,} \]
	gdzie \(X\) jest dowolnym podzbiorem \(V(G)\). Wówczas
	\[ \text{cutwidth}_{\sigma}(i) \ = \ \text{out}(\{v_{\sigma_{1}}, \ldots,
	v_{\sigma_{i}}\}) \text{.} \]
	Oczywiście, dla konkretnego \(X\), wartość \(\text{out}(X)\) można łatwo
	obliczyć w czasie \(n^{\mathcal{O}(1)}\).
	
	\medskip
	
	Pozwala nam to skorzystać z programowania dynamicznego po podzbiorach. Niech
	\[ \text{dp}(X) \ = \ \min \left\{ \underset{i \in
	\{1, \ldots, |X| - 1\}}{\max} \ \text{cutwidth}_{\sigma}(i) \ : \ \sigma \in
	S_{n} \ \wedge \ \{v_{\sigma_{1}}, \ldots, v_{\sigma_{|X|}}\} = X \right\}
	\text{,} \]
	gdzie \(X\) jest dowolnym podzbiorem \(V(G)\). Wtedy
	\begin{align*}
		\text{dp}(\emptyset) \ &= \ 0 \text{,} \\
		\text{dp}(X) \ &= \ \min \{\max(\text{dp}(X \setminus \{x\}),
		\text{out}(X \setminus \{x\}) \ : \ x \in X\} \text{.}
	\end{align*}
	Naturalnie, wynikiem jest \(\text{dp}(\{1, \ldots, n\})\). Żeby obliczyć
	wartości \(\text{dp}\) dla wszystkich podzbiorów \(V(G)\), można na przykład
	przeglądać je w kolejności niemalejących rozmiarów. Całkowita złożoność
	naszego algorytmu wynosi \(2^{n} \cdot n^{\mathcal{O}(1)}\).
	
	\newpage
	
	\textbf{Zadanie 2}
	
	\medskip
	
	\underline{Lemat 1} Zbiór punktów \(S\), w którym żadne trzy nie są
	współliniowe, nie tworzy wierzchołków wielokąta wypukłego wtedy i tylko
	wtedy, gdy istnieją punkty \(A, B, C, D \in S\) takie, że punkt \(D\) leży
	wewnątrz \(\triangle ABC\).
	
	\medskip
	
	\underline{Dowód lematu 1} Implikacja ,,w lewo'' jest oczywista, skupmy się
	więc na implikacji ,,w prawo''. Niech \(\{H_{1}, \ldots, H_{h}\}\) będzie
	otoczką wypukłą zbioru \(S\), przy czym zakładamy, że punkty te leżą na
	otoczce w tej kolejności zgodnie z kierunkiem przeciwnym do ruchu wskazówek
	zegara. Niech \(D\) będzie dowolnym punktem z \(S\) nieleżącym na otoczce
	oraz niech \(A = H_{1}\). Istnieje wówczas dokładnie jedno \(i \in \{2,
	\ldots, h - 1\}\) takie, że punkty \(H_{2}, \ldots, H_{i}\) leżą po jednej
	stronie prostej \(AD\), a punkty \(H_{i + 1}, \ldots, H_{h}\) po drugiej.
	Biorąc \(B = H_{i}\) oraz \(C = H_{i + 1}\) otrzymamy szukane punkty.
	
	\medskip
	
	Z udowodnionego lematu wynika, że jeśli istnieją punkty \(A, B, C, D \in S\)
	takie, że punkt \(D\) leży wewnątrz \(\triangle ABC\), to co najmniej jeden
	z nich musi zostać usunięty z \(S\). Obserwacja ta prowadzi do następującego
	algorytmu:
	
	\begin{algorithm}
		\caption{ConvexDeletion}
		\begin{algorithmic}[1]
			\Procedure{ConvexDeletion}{$S, k$}
			    \If{no four points $A, B, C, D \in S$ satisfy that $D$ lies
			        inside $\triangle ABC$}
			        \State \Return true
			    \EndIf
			    \If{$k \leqslant 0$}
			        \State \Return false
			    \EndIf
			    \State Choose points $(A, B, C, D) \in S$ such that $D$ lies
			           inside $\triangle ABC$
			    \State \Return \Call{ConvexDeletion}{$S \setminus \{A\}, k - 1$}
			           \textbf{or}
			           \Call{ConvexDeletion}{$S \setminus \{B\}, k - 1$}
			           \textbf{or}
			    \Statex \hspace{4.685em}
			           \Call{ConvexDeletion}{$S \setminus \{C\}, k - 1$}
			           \textbf{or}
			           \Call{ConvexDeletion}{$S \setminus \{D\}, k - 1$}
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	Szukanie takich czwórek punktów \(A, B, C, D\) można łatwo zrealizować w
	czasie \(\mathcal{O} \big( n^{4} \big)\), przeglądając wszystkie czwórki
	punktów, dla każdej licząc odpowiednie iloczyny wektorowe i porównując ich
	znaki. Można to również zrobić w czasie \(\mathcal{O} (n \log n)\),
	obliczając otoczkę wypukłą przy pomocy algorytmu Grahama i korzystając z
	konstrukcyjnego dowodu lematu 1.
	
	\medskip
	
	Głębokość drzewa rekurencji naszego algorytmu wynosi co najwyżej \(k\),
	ponieważ przy wywołaniu rekurencyjnym parametr \(k\) zmniejsza się o \(1\).
	Każdy wierzchołek tego drzewa ma co najwyżej czterech synów, skąd dostajemy
	górne oszacowanie na liczbę wierzchołków drzewa:
	\[ \sum\limits_{i = 0}^{k} 4^{i} \ = \ \frac{4^{k + 1} - 1}{3} \ = \
	\mathcal{O} \big( 4^{k} \big) \text{.} \]
	Łączna złożoność naszego algorytmu wynosi zatem
	\(\mathcal{O} \big( 4^{k} \big) \cdot n^{\mathcal{O}(1)}\).
\end{document}
