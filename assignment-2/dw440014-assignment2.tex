\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{float}
\usepackage[a4paper, margin = 2 cm]{geometry}
\usepackage{fancyhdr}
\usepackage{wrapfig}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algpseudocode}

\title{Parameterized Algorithms assignment 2}
\author{Dominik Wawszczak}
\date{2024-12-01}

\begin{document}
	\setlength{\parindent}{0 cm}
	
	Dominik Wawszczak \hfill Parameterized Algorithms
	
	Student ID Number: 440014 \hfill Assignment 2
	
	Group Number: 1
	
	\bigskip
	\hrule
	\bigskip
	
	\textbf{Problem 1}
	
	\medskip
	
	If \(G\) is not connected, we can analyze each connected component
	independently, subtracting the combined sizes of all other components from
	\(k\). Thus, for the remainder of the solution, we assume that \(G\) is
	connected.
	
	\medskip
	
	If there exists a subset of vertices \(X\) such that \(|X| \leqslant k\) and
	\(G \setminus X\) is a tree, then \(\text{tw}(G) \leqslant k + 1\), as
	\(\text{tw}(G \setminus X) = 1\), where \(\text{tw}\) denotes treewidth. We
	will use the algorithm presented in the lecture, which runs in time \(27^{l}
	\cdot l^{\mathcal{O}(1)} \cdot n^{2}\), where \(l\) is the target treewidth
	and \(n\) is the number of vertices. We apply it to \(G\) with \(l = k +
	1\). The algorithm will yield one of two possible outcomes:
	\begin{enumerate}
		\item Confirmation that \(\text{tw}(G) > k + 1\).
		      
		      In this case, we conclude that no such subset \(X\) exists.
		
		\item A tree decomposition of width at most \(4k + 8\).
		      
		      The remainder of the solution focuses on this scenario.
	\end{enumerate}
	
	\medskip
	
	We now proceed with dynamic programming, assuming the decomposition is nice.
	For any subtree \(H\) of the decomposition and its boundary \(\partial H\),
	let \(f : V(\partial H) \to \{0, \ldots, 4k + 9\}\). Define
	\(\text{dp}_{H}(f)\) as the size of the minimum set \(Y \subseteq
	V(H \setminus \partial H)\) satisfying the following conditions:
	\begin{enumerate}
		\item \(H \setminus \big( Y \cup f^{-1}(0) \big)\) is a forest,
		\item for all \(v, u \in V(\partial H) \setminus f^{-1}(0)\), \(v\) and
		\(u\) are in the same connected component of \(H \setminus \big( Y \cup
		f^{-1}(0) \big)\) if and only if \(f(v) = f(u)\).
	\end{enumerate}
	If no such set \(Y\) exists for a given \(f\), we define \(\text{dp}_{H}(f)
	= \infty\).
	
	\medskip
	
	To compute \(\text{dp}_{H}\), we consider the following cases:
	\begin{enumerate}
		\item \(H = \text{introduceVertex}(H', v)\)
		      
		      Here, \(\text{dp}_{H}(f) = \min(\{\text{dp}_{H'}(f') \ : \ f =
		      f'[v \mapsto f(v)] \ \wedge \ f'^{-1}(f(v)) = \emptyset\})\),
		      where \(\min(\emptyset) = \infty\). We use the notation
		      \(f[a \mapsto b]\) to denote the function \(g\) defined by:
		      \[ g(x) \ = \ \begin{cases} b \text{,} & \text{if} \ x = a
		      \text{,} \\ f(x) \text{,} & \text{otherwise.} \end{cases} \]
		
		\item \(H = \text{introduceEdge}(H', v, u)\)
		      
		      In this case, \(\text{dp}_{H}(f) = \min(\{\text{dp}_{H'}(f') \ : \
		      f'(v) \neq f'(u) \ \wedge \ (f'(w) = f'(v) \ \vee \ f'(w) = f'(u))
		      \ \Rightarrow \ f(w) = f(v) = f(u)\})\).
		
		\item \(H = \text{forgetVertex}(H', v)\)
		      
		      Here, \(\text{dp}_{H}(f) = \min(\{\text{dp}_{H'}(f') + [k = 0] \ :
		      k \in \{0, \ldots, 4k + 9\} \ \wedge \ f' = f[v \mapsto k]\})\),
		      where \([P]\) denotes the Iverson bracket, i.e., \([P] = 1\) if
		      \(P\) is true, and \([P] = 0\) otherwise.
		
		\item \(H = \text{merge}(H', H'')\)
		      
		      In this case \(\partial H' = \partial H''\), and we calculate
		      \(\text{dp}_{H}\) as \(\text{dp}_{H}(f) = \text{dp}_{H'}(f) +
		      dp_{H''}(f)\).
	\end{enumerate}
	The answer is \(\text{dp}_{T}(\text{empty function}) \leqslant k\), where
	\(T\) is the entire decomposition.
	
	\medskip
	
	The total complexity is bounded by
	\[ 27^{k + 1} \cdot (k + 1)^{\mathcal{O}(1)} \cdot n^{2} +
	n^{\mathcal{O}(1)} \cdot \left( (4k + 10)^{4k + 10} \right)^{2} \text{,} \]
	thus this algorithm is FPT when parameterized by \(k\).
	
	\bigskip
	
	\textbf{Problem 2}
	
	\medskip
	
	We apply the color-coding technique. Let \(c = k(l - 1)\) denote the
	maximum total number of vertices along the paths, excluding the start and
	finish vertices. We color each vertex (excluding the start and finish
	vertices) with one of \(c\) colors. For each \(i \in \{1, \ldots, k\}\), let
	\(\text{dp}_{i}[v][C]\) be true if and only if there exists a path from
	\(s_{i}\) to \(v\) such that the set of vertex colors on this path equals
	exactly \(C\), with no two vertices sharing the same color. Here, we only
	consider subsets \(C\) of size at most \(l - 1\).
	
	\medskip
	
	The values of \(\text{dp}_{i}\) are initially set to \(\text{false}\) and
	are then computed using the following rules:
	\begin{enumerate}
		\item \(\text{dp}_{i}[s_{i}][\emptyset] \ = \ \text{true}\).
		\item \(\text{dp}_{i}[v][C] \ = \ \bigvee\limits_{(u, v) \in E(G)}
		      (\text{color}[v] \in C \ \wedge \
		      \text{dp}_{i}[u][C \setminus \{\text{color}[v]\}])\), for all
		      \(v \in V(G) \setminus \bigcup\limits_{j = 1}^{k} \{s_{j}, t_{j}\}\).
		\item \(\text{dp}_{i}[t_{i}][C] \ = \ \bigvee\limits_{(u, t_{i}) \in
		      E(G)} \text{dp}_{i}[u][C]\).
	\end{enumerate}
	To compute these values correctly, ensuring that no \(\text{dp}\) entry is
	referenced before it has been calculated, subsets \(C\) are considered in
	increasing order of size. Subsequently, \(\text{dp}_{i}[v][C]\) is filled
	for all \(v \in V(G)\).
	
	\medskip
	
	The number of such subsets is bounded by:
	\[ \sum\limits_{j = 0}^{l - 1} \binom{c}{j} \ \leqslant \
	\sum\limits_{j = 0}^{l - 1} c^{j} \ = \ \frac{c^{l} - 1}{c - 1} \ \leqslant
	\ c^{l} \ = \ (k (l - 1))^{l} \ \leqslant \ (kl)^{l} \text{.} \]
	Thus, this computation requires \(\mathcal{O} \big( (kl)^{l} k (n + m)
	\big)\) time, where \(n = |V(G)|\), and \(m = |E(G)|\).
	
	\medskip
	
	The number of \(k\)-tuples of such subsets is bounded by \(\big( (kl)^l
	\big)^{k} = (kl)^{kl}\). We iterate over these tuples, performing the
	following for each \((C_{1}, \ldots, C_{k})\):
	\begin{enumerate}
		\item Verify that the subsets \(C_{1}, \ldots, C_{k}\) are pairwise
		      disjoint.
		      
		      This step can be done in \(\mathcal{O}(k^{3} l)\) time.
		
		\item Check whether \(\text{dp}_{1}[t_{1}][C_{1}] = \ldots =
		      \text{dp}_{k}[t_{k}][C_{k}] = \text{true}\).
		      
		      In this case, the answer to the problem is ,,Yes.''.
	\end{enumerate}
	The time complexity of one iteration is \(\mathcal{O} \big( (kl)^l k (n + m)
	+ (kl)^{kl} k^{3} l \big)\).
	
	\medskip
	
	The probability of a single iteration failing to find a solution, assuming
	one exists, is \(1 - \frac{c!}{c^{c}}\), as there are \(c^{c}\) ways to
	assign \(c\) colors to \(c\) vertices, and \(c!\) of these avoid duplicate
	colors. Repeating the iteration \(e^{c}\) times reduces the failure
	probability to:
	\[ \bigg( 1 - \frac{c!}{c^{c}} \bigg)^{e^{c}} \ < \ \bigg( 1 -
	\frac{1}{e^{c}} \bigg)^{e^{c}} \ < \ 1 - \frac{1}{e} \text{,} \]
	a constant.
	
	\medskip
	
	The total time complexity is:
	\[ \mathcal{O} \big( e^{kl} \big( (kl)^l k (n + m) + (kl)^{kl} k^{3} l \big)
	\big) \text{,} \]
	which is FPT when parameterized by \(k + l\), as \(kl \leqslant
	(k + l)^{2}\).
	
	\medskip
	
	This algorithm can be determinized using an \((n, c, c)\)-splitter, as
	discussed in the lecture. The splitter, with size \(e^{c}
	c^{\mathcal{O}(\log c)}\), can be found in time \(e^{c}
	c^{\mathcal{O}(\log c)} n \log n\). The resulting complexity is:
	\[ e^{kl} (kl)^{\mathcal{O}(\log kl)} \big( n \log n + \mathcal{O} \big(
	(kl)^l k (n + m) + (kl)^{kl} k^{3} l \big) \big) \text{,} \]
	which is also FPT when parameterized by \(k + l\), completing the proof.
\end{document}
